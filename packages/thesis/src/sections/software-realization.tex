\section{Software Realization}
\label{sec:software-realization}
To fully understand the ADRIAN protocol \cite{mann2023ADRIAN}, we have to implement a prototype of the protocol. This section describes the design and implementation of the ADRIAN protocol, as well as the experimental setup used to evaluate the protocol. The implementation is done in Java, and the source code can be found on GitHub\footnote{\url{https://github.com/jornverhoeven/thesis-project}}. 


\subsection{Overview}
\label{ssec:overview}
% \comment{Zoltan}{It would be a good to add an overview diagram that shows the structure of the while program on a higher level of abstraction than individual classes.}
To start things off we will give a brief overview of the components of the ADRIAN prototype. The component overview can be seen in Figure \ref{fig:adrian-component-overview}, and will be used as a reference throughout this section.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{_content/adrian-component-overview.png}
    \caption{Overview of the components of the ADRIAN protocol. The \code{MessageBroker} is responsible for interfacing with the external world, while the \code{EventBus} is used for internal communication. The \code{Controllers} are responsible for handling the different aspects of the agent, such as knowledge sharing and auctions. They are each responsible for a specific set of events and are connected to the event bus.}
    \label{fig:adrian-component-overview}
\end{figure}

For the architecture design of the prototype, we wanted to create something that is easy to understand, maintain, and instrument. To achieve this, we chose to implement an Event-Driven architecture. This architecture is based on the Observer pattern \cite{gamma1995design}, commonly used in software development. By sending messages through an event bus (See \code{EventBus} in figure \ref{fig:adrian-component-overview}), we can decouple the different components of the system. Next to being able to decouple the components, it also allows us to easily instrument the system. By listening to the events on the event bus during our experiments, we can count the number of events and the time between events. This allows us to easily collect metrics of the system. More on these metrics in Section \ref{ssec:metrics}.

Each controller in our design is responsible for a specific set of events and is connected to the event bus. This allows us to easily add new controllers, or replace existing ones during our experiments. The controllers are responsible for handling the different aspects of the agent. 

\begin{enumerate}
    \item The \code{KnowledgeController} is responsible for receiving and sharing knowledge. 
    \item The \code{RiskController} is responsible for detecting risks.
    \item The \code{AuctionController} is responsible for handling auctions. 
    \item The \code{ProposalController} is responsible for finding and applying proposals.
\end{enumerate}

We chose to detach the external communication from the internal communication. This allows us to easily replace the external communication with a different implementation. More on this in Section \ref{sssec:message-broker}.
The \code{MessageBroker} is the layer for interfacing with the external world. The \code{MessageBroker} is responsible for sending and receiving messages from other agents and dispatching them to the event bus.

\subsection{Class Diagrams}
\label{ssec:class-diagrams}
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

In this section, we present an overview and analysis of a UML Class Diagram for our proposed implementation of the ADRIAN protocol \cite{mann2023ADRIAN} which can be seen in Figures \ref{fig:uml-agent} through \ref{fig:uml-services}. At a glance, the architecture features multiple controllers, connected through an internal event bus, and a message broker external communication. Additionally, some classes have been extended to support the experimental setup, which is further explained in Section \ref{sec:experiments}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{_content/uml-agent}
    \caption{UML Diagram of the code structure of an Agent.}
    \label{fig:uml-agent}
\end{figure}

\subsubsection{Increased Cohesion and Reduced Coupling through Controller Interfaces}
\label{sssec:reduced-cohesion-coupling}
The systems architecture uses multiple controllers to handle various aspects of the agent, aiming to reduce both cohesion and coupling between components. Each controller is responsible for a specific set of tasks and the corresponding events, leading to a more modular and flexible design. This separation of functionality allows for easier maintenance, as well as the ability to replace controllers with new implementations, minimizing the impact on other parts of the system.

\subsubsection{Event Bus for internal communication}
\label{sssec:event-bus}
To enable communication between controllers, an internal event bus is created. The event bus is in essence nothing more than a Observer pattern (also known as \texttt{EventEmitter} or \texttt{Pup/Sub})\cite{gamma1995design}. This decouples the controllers from one another, as they are not directly aware of each other. Controllers can publish and subscribe to events on the event bus, and the event bus will then notify all subscribers when an event is published. 

\subsubsection{Controllers as an interfacing layer}
\label{sssec:controllers-interfacing-layer}
Controllers serve as an interfacing layer, between the event bus and the services responsible for the computations. This abstraction shields the services from the complexities of event handling, promoting modularity and reusability. It allows the services to be reused in other contexts and makes the code easier to test as it is not dependent on any external form of communication (which is handled by the controllers).

\subsubsection{Message Broker for external communication}
\label{sssec:message-broker}
The system uses a \code{MessageBroker} which facilitates communication between agents. It allows for both incoming and outgoing messages to be handled by the agent while abstracting away the underlying protocol. Incoming messages are processed and dispatched onto the internal event bus, triggering the relevant controllers to handle the message. On the other hand, outgoing messages are sent to the \code{MessageBroker}, which then sends the message to the appropriate agent.

\add{Rewrite the following paragraph to be easier to understand}
The \code{MessageBroker} as an interface can be concretized by different implementations, depending on hardware-/software-requirements. In the experimental setup, a single \code{MessageBroker} is used by all agents and works directly in memory. This avoids any additional network complexity and allows for easier simulation. In a real-world scenario, the \code{MessageBroker} would be a network service, which is used to send messages between agents over the network using HTTP requests or some other protocol such as MQTT. From the agent's perspective, the \code{MessageBroker} would be the same, regardless of the implementation, and thus reducing coupling between the agents and the underlying communication protocol.

\subsubsection{Similarities in graph data structures}
\label{sssec:graph-data-structures}
In the real world, the infrastructure is a graph structure, something that it \comment{Zoltan}{This could be interpreted in such a way that the speicific graph is hard-coded in the program. I think this is not what you want to say} captured in the code of the agent as well. The \code{Infrastructure}-graph consists of two types of nodes; \code{InfrastructureNode} and \code{SoftwareComponent}. These nodes can be mapped to actual hardware (e.g. Servers and IoT devices) and software (e.g. Databases and Services) in real-world applications, their concrete implementation is intentionally left away to reduce overhead and complexity.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.2\textwidth]{_content/uml-graphs}
    \caption{UML Diagram explaining the structure of the Graphs, in a way that the separate classes are similar to their counterparts.}
    \label{fig:uml-graphs}
\end{figure}

\subsubsection{Services}
\label{sssec:services}
Each controller is only responsible for converting events into service calls. But to implement the actual logic, the controllers use services. These services are responsible for the actual computations, such as calculating the \code{AttackGraphs} or finding \code{Proposal}s. Figure \ref{fig:uml-services} shows how the services are tied together.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{_content/uml-services}
    \caption{UML Diagram depicting how the Agent's services are tied together.}
    \label{fig:uml-services}
\end{figure}

\begin{description}
    \item[RiskDetection] This service is responsible for detecting risks in the infrastructure. It does this by calculating the attack graph for each node in the infrastructure. With the attack graph, it can then identify \textit{Critical Paths} by finding paths from nodes to a \textit{critical software component}. These \textit{Critical Paths} are then used to calculate the risk damage value. We calculate the risk damage by taking the potential damage value of a software component and multiplying it by the probability of the path. The probability is calculated over all edges between nodes, that are in the same direction of the critical path. 
    \begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.4\textwidth}
            \centering
            \includegraphics[width=\textwidth]{_content/attack-graph.png}
            \caption{Attack graph between nodes and software components}
            \label{fig:attack-graph}
        \end{subfigure}
        \hspace{0.5cm}
        \centering
        \begin{subfigure}[b]{0.4\textwidth}
            \centering
            \includegraphics[width=\textwidth]{_content/riskreport-future-research-a.png}
            \caption{Risk report for a critical path}
            \label{fig:risk-report}
        \end{subfigure}
        \caption{On the left is the graph representation of an attack graph, where each edge is a risk that holds a probability of an attacker exploiting it. The graph is directional and can hold edges in multiple directions. On the right is the graph representation of a risk report. The risk report is also directional but only contains the edges that are in the same \textit{direction} as the critical path. Both graphs can have incoming edges to indicate that a node could be the starting point of an attack.}
    \end{figure}

    \item[ProposalService] This service is responsible for calculating proposals that the node is willing to apply. It does this by taking the risk report from an auction and applying different adaptations to it. For example, an adaptation could be to update the properties of a node or software or migrate a software component to another node. The service then calculates the risk damage value for each adaptation and returns the adaptation with the lowest risk damage value. This adaptation is then used as a bid in the auction, for the auctioneer to consider. 
    
    \item[AuctionManager] This service is responsible for starting and managing the state of an auction. When it starts a new auction, it will send invitations to other agents and wait for their replies (accept or reject). It will also keep track of the current state of the auction and wait for proposals to be submitted. When a proposal is submitted, it will check if all participating nodes replied. If this is the case, it will calculate the risk damage value for each proposal, and select the proposal with the lowest risk damage value. This proposal is then broadcast to all participating nodes, and the auction is finished. The manager will then wait for the next auction to start. There might also be cases where participating nodes fail to send proposals. For these cases, the \code{AuctionManager} has a timeout that starts when an auction starts. If the timeout is reached, the manager will finish the auction at that point, and select the proposal with the lowest risk damage value. If no applicable proposals are received, the auction is canceled and nothing is done.
\end{description}

% \subsection{Sequence Diagrams}
% \label{ssec:sequence-diagrams}
% \add{Update text or remove section}
% \begin{figure}[H]
%     \centering
%     \includegraphics[width=0.8\textwidth]{_content/knowledge-sharing}
%     \caption{Knowledge Exchange Sequence Diagram}
%     \label{fig:knowledge-sharing}
% \end{figure}

% \begin{figure}[H]
%     \centering
%     \includegraphics[width=0.8\textwidth]{_content/auction}
%     \caption{Auction Sequence Diagram}
%     \label{fig:auction}
% \end{figure}

% \addtocontents{toc}{\protect\setcounter{tocdepth}{3}}

\subsection{Risk Rules \& Mutations}
In this section we will describe the risk rules and mutations that are used in the ADRIAN protocol \cite{mann2023ADRIAN}. The risk rules are used to identify risks in the infrastructure. These rules look at the different properties of the infrastructure and software components, and based on these properties, they can identify a risk between two nodes, software or any combination of those two. 

To implement the risk rules we've chosen to distinguish between three types of risks; \emph{Forward risks}, \emph{Backwards risks}, and \emph{Inward risks}. \emph{Inward risks} are nearly identical to \emph{Backwards risks}, the only theoretical distinction is that inward risks always come from a void-node, whereas backwards risks only come from entities on the graph. Figure \ref{fig:risk-rules} gives a visual representation of the differences between these three types of risks.

\begin{figure}[H]
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{_content/risk-rules-forward.png}
        \caption{Forward risk rule.}
        \label{fig:risk-rule-forward}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{_content/risk-rules-backward.png}
        \caption{Backwards risk rule.}
        \label{fig:risk-rule-backward}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{_content/risk-rules-inward.png}
        \caption{Inwards risk rule.}
        \label{fig:risk-rule-inward}
    \end{subfigure}
    \caption{A representation of the three different risk rules. The asterisk (*) represents a property that would trigger the risk rule. The arrows represent the direction of the risk. Any square could be either a node or a software component. In the case of Inward rules, the parent will always be the void node.}
    \label{fig:risk-rules}
\end{figure}


The mutations are used to adapt the infrastructure and software components. These mutations are used to reduce the risk in the infrastructure.

\add{Add table of all riskrules that were used.}
\add{Explain the different mutations that were used.}

\subsection{Calculating probabilities}
\label{ssec:calculating-probabilities}

\[p = 1 - \prod_{k=1}^{R}(1-p_{k}) \]


\subsection{Migrations} 
\label{ssec:migrations}
While developing and experimenting with the ADRIAN protocol, we noticed that the mitigation strategy to migrate software from one node to another is seldom applied. Only under special circumstances will the agents propose to migrate software from one node to another. To illustrate some of the reasons why this is the case, we will sketch several cases that where encountered during the experiments, and why the agents did not \emph{(and should not)} propose to migrate software.

\paragraph*{Migrating along the critical path}
In figure \ref{fig:migrations-example} we see a simplified infrastructure. The critical path from node A to software S1 is shown in red. If we were to migrate software S1 to node A, the critical path would be shortened as shown in figure \ref{fig:migrations-shortened}. None of the properties change and all edge-probabilities stay the same, only the critical path does. This means that the damage would in almost all cases increase, as any additional edges (unless the probability is exactly 1) decrease the probability of the attack graph, because each probability is always \(0 \leq p \leq 1\). 

Only if the new edge between node A and software S1 has a significantly reduced probability, would the migration be beneficial. However, because the properties of A and S1 do not change, this is unlikely to happen. 

\begin{figure}[H]
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{_content/migrations/migrations.png}
        \caption{Basic infrastructure.}
        \label{fig:migrations-infrastructure}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{_content/migrations/migrations-a.png}
        \caption{Critical path.}
        \label{fig:migrations-basic}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{_content/migrations/migrations-c.png}
        \caption{Proposed migration.}
        \label{fig:migrations-shortened}
    \end{subfigure}
    \caption{A simplified representation of an infrastructure, to illustrate the effect of migrations on the risk probability. (a) Shows the overall infrastructure. (b) shows in red a critical path from node A to software S1. (c) shows in red the critical path after a migration proposal.}
    \label{fig:migrations-example}
\end{figure}

\paragraph*{Migrating outside the critical path}
As per our previous example from Figure \ref{fig:migrations-example} we see that migrations along the critical path are usually not beneficial. However, migrations could be a viable option when migrating to neighboring nodes on the critical path. In figure \ref{fig:migrations-outside} we show what a migration outside of the critical path could look like. In this example we see that the critical path from node A to software S1 is shown in red. If we were to migrate software S1 to node C, the critical path would be shortened as shown in figure \ref{fig:migrations-outside-proposal}. This time the overall probability could decrease as expected.  

\begin{figure}[H]
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{_content/migrations/migrations.png}
        \caption{Basic infrastructure.}
        \label{fig:migrations-outside-infrastructure}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{_content/migrations/migrations-a.png}
        \caption{Critical path.}
        \label{fig:migrations-outside-attack}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{_content/migrations/migrations-d.png}
        \caption{Proposed migration.}
        \label{fig:migrations-outside-proposal}
    \end{subfigure}
    \caption{A simplified representation of an infrastructure, to illustrate the effect of migrations outside of the critical path . (a) Shows the overall infrastructure. (b) shows in red a critical path from node A to software S1. (c) shows in red the critical path after a migration proposal.}
    \label{fig:migrations-outside}
\end{figure}

The ADRIAN concept by Mann \& Smolka \cite{mann2023ADRIAN} initially mentions that agents could only invite other agents that are on the critical path. This would mean that the migration from Figure \ref{fig:migrations-outside} are not possible. However, a small note was made in the concept that potentially others could be invited as well. We believe that this is a good idea, and has been implemented in our system as well.

\paragraph*{Calculating risk deltas}
When calculating the effectiveness of a mutation, the original ADRIAN concept by Mann \& Smolka \cite{mann2023ADRIAN} mentions that the new probability of the critical path should be calculated. For simple attribute changes this is easy as the critical path stays the same, and the changes are always optimistic\footnote{When implementing the risk rule and its adaptation, we change a property so it never creates a higher risk. It will only ever reduce the risk, or remove it completely.}. However, in case of migrations this calculation becomes a bit more complex. 

When migrating software from one node to another, the critical path changes. This means that the new critical path has to be calculated, and the new risk probability has to be calculated. This as a calculation is only a bit more complex than the evaluation for attribute changes. However, the problem with a migration is that new risks could be introduced in the infrastructure, outside the critical path. Figure \ref{fig:migrations-delta} illustrates this problem in more detail.

\begin{figure}[H]
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{_content/migrations/migrations-delta-a.png}
        \caption{Critical path.}
        \label{fig:migrations-delta-attack}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{_content/migrations/migrations-delta-b.png}
        \caption{Proposed migration.}
        \label{fig:migrations-delta-proposal}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{_content/migrations/migrations-delta-c.png}
        \caption{New risks.}
        \label{fig:migrations-delta-risks}
    \end{subfigure}
    \caption{A simplified representation of an infrastructure, to illustrate the effect of migrations outside of the critical path . (a) shows in red a critical path from node A to software S1. (b) shows in red the critical path after a migration proposal. (c) shows in red a potential new risk that is introduced.}
    \label{fig:migrations-delta}
\end{figure}

Since these new risks are not on the critical path, they are not taken into account when calculating the risk probability. This means that a migration could make sense for a specific risk, but could introduce new risks that are not taken into account. This could lead to a situation where the risk probability of the critical path is reduced, but the overall risk probability of the infrastructure is increased. 

To mitigate this problem, we've implemented logic that detects risks from its knowledge base before a mutation is applied, and after a mutation is applied. The software then calculates a delta between the two, both in size and total damage. If there are too many new risks introduced, or the total damage increases too much, the mutation is not applied. This adds an additional safeguard to the system, and prevents the agents from applying mutations that could potentially increase the overall damage of the infrastructure.
