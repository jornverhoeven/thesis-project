package tech.jorn.adrian.risks.rules.cves;

import tech.jorn.adrian.core.graphs.AbstractDetailedNode;
import tech.jorn.adrian.core.graphs.knowledgebase.KnowledgeBase;
import tech.jorn.adrian.core.graphs.knowledgebase.KnowledgeBaseEntry;
import tech.jorn.adrian.core.graphs.knowledgebase.KnowledgeBaseNode;
import tech.jorn.adrian.core.graphs.knowledgebase.KnowledgeBaseSoftwareAsset;
import tech.jorn.adrian.core.mutations.AttributeChange;
import tech.jorn.adrian.core.mutations.Mutation;
import tech.jorn.adrian.core.mutations.SoftwareAttributeChange;
import tech.jorn.adrian.core.properties.AbstractProperty;
import tech.jorn.adrian.core.properties.NodeProperty;
import tech.jorn.adrian.core.properties.SoftwareProperty;
import tech.jorn.adrian.core.risks.Risk;
import tech.jorn.adrian.core.risks.RiskEdge;
import tech.jorn.adrian.risks.validators.PropertyValidator;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.function.Consumer;

public class SdkVulnerabilityCve extends CveRule<String> {


    private final String mitigatedVersion;

    public SdkVulnerabilityCve(String cve, String sdk, PropertyValidator<String> validator, float exploitabilityScore, String mitigatedVersion) {
        super(cve, "sdk-"+sdk+"-version", validator, exploitabilityScore);
        this.mitigatedVersion = mitigatedVersion;
    }

    @Override
    public void evaluate(KnowledgeBase knowledgeBase, Consumer<RiskEdge> attackGraph) {
        List<KnowledgeBaseEntry<?>> software = new ArrayList<>();

        knowledgeBase.getNodes().forEach(node -> {
            if (node instanceof KnowledgeBaseSoftwareAsset) software.add(node);
        });

        software.forEach(s -> {
            var property = s.getProperty(this.getProperty());
            if (property.isEmpty()) return;

            var isVulnerable = this.validator.validate((String) property.get());
            if (!isVulnerable) return;

            var parents = knowledgeBase.getParents(s);
            parents.forEach(parent -> {
                if (!(parent instanceof KnowledgeBaseNode)) return;
                var risk = new Risk(this.getCve(), this.getExploitabilityScore() / 10, false, this);
                attackGraph.accept(new RiskEdge(parent, s, risk));
            });
        });
    }

    @Override
    public <N extends AbstractDetailedNode<P>, P extends AbstractProperty<?>> Optional<Mutation<N>> getAdaptation(N node) {
        if (this.mitigatedVersion == null) return Optional.empty();
        if (!(node instanceof KnowledgeBaseSoftwareAsset)) return Optional.empty();

        var adaptation = new SoftwareAttributeChange<>(node, new SoftwareProperty<>(this.getProperty(), this.mitigatedVersion), this);
        return Optional.of(adaptation);
    }
}
